package de.mannodermaus.example.test.composition.lifecycle

import de.mannodermaus.example.Card
import de.mannodermaus.example.Deck
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.DynamicTest.dynamicTest
import org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS
import java.util.stream.IntStream
import java.util.stream.Stream

// This test interface will, given a Deck,
// draw every Card from it one by one,
// and invoke a callback method on implementing classes.
// This is an example of how the test lifecycle can be introduced
// to test interfaces as well! Furthermore, another property
// of DynamicTest objects is demonstrated here, because we can see
// that @BeforeEach and @AfterEach are not invoked for each individual item
// generated by a @TestFactory. Rather, only the @TestFactory itself
// is embedded into these callbacks
@TestInstance(PER_CLASS)
interface DrawEntireDeck {

    val deck: Deck

    @BeforeAll
    fun beforeAll() {
        println("Created a new deck.")
    }

    @BeforeEach
    fun beforeEach() {
        deck.shuffle()

        // While executing, note how this log message is not repeated
        // in-between each DynamicTest! The test() method itself partakes
        // in the test lifecycle, but its individual return values do not.
        println("Shuffled the deck.")
    }

    @TestFactory
    fun test(): Stream<DynamicTest> {
        val repetitions = deck.size
        return IntStream.range(0, repetitions)
                .mapToObj { repetition ->
                    dynamicTest("Card #$repetition") {
                        // Until the deck is empty,
                        // draw another Card and pass it to the interface method.
                        val nextCard = deck.draw()
                        assertDrawnCard(nextCard)
                    }
                }
    }

    // Implemented by subclasses, invoked once for each test
    fun assertDrawnCard(card: Card)

    @AfterEach
    fun afterEach() {
        // Like with @BeforeEach, this will only ever log once.
        println("Remaining cards in the deck: ${deck.size}")
    }

    @AfterAll
    fun afterAll() {
        println("Check if deck is empty now.")
        assertTrue(deck.isEmpty())
    }
}